
package parser;

import model.*;
import java.util.*;
import java.io.*;

/**
 *	Syntactic analyser and Semantic Analyser
 *
 *	The parser uses tokens generated by lexical analyser
 *	to parse all tokens to validate the syntax.
 *
 *	@author Zaw Moe Htat (c3193528@uon.edu.au)
 */

public class Parser {

	/**
	 *	List of tokens generated by lexical analyser
	 */
	private LinkedList<Token> tokens;

	/**
	 *	Scope stack
	 */
	private LinkedList<String> scopeStack;

	/**
	 *	List of errors detected
	 */
	private LinkedList<ErrorHandler> errors;

	/**
	 *	List of semantic errors
	 */
	private LinkedList<ErrorHandler> semanticErrors;

	/**
	 *	Currently parsing line number
	 */
	private int currentReadingLineNumber;

	/**
	 *	Symbol tables
	 */
	private SymbolTable symbolTable;

	/**
	 *	For main id
	 */
	private String mainVar;

	/**
	 *	Constructor
	 *
	 *	Initialise all member variables.
	 *
	 *	@param tokens List of tokens generated by lexical analyser
	 */
	public Parser(LinkedList<Token> tokens) {
		this.tokens = tokens;
		this.scopeStack= new LinkedList<String>();
		this.errors = new LinkedList<ErrorHandler>();
		this.semanticErrors = new LinkedList<ErrorHandler>();
		this.currentReadingLineNumber = 1;
		this.symbolTable = new SymbolTable();
	}

	/**
	 *	Parse the program
	 *
	 *	@return Syntax tree with all nodes.
	 */
	public TreeNode parse() {
		return this.sProgram();
	}

	/**
	 *	Get all error messages
	 *
	 *	@return List of error messages.
	 */
	public LinkedList<ErrorHandler> getErrorHandler() {
		return this.errors;
	}

	/**
	 *	Get all semantic error messages
	 *
	 *	@return List of semantic error messages.
	 */
	public LinkedList<ErrorHandler> getSemanticErrorHandler() {
		return this.semanticErrors;
	}

	// ==================================================
	// Helper
	// ==================================================

	/**
	 *	Consume the token from token list
	 *
	 *	@return Token being consumed
	 */
	private Token consume() {

		/**
		 *	Make sure the token is not empty
		 */
		if (this.tokens.size() == 0) {
			return null;
		}

		// Get token out from the list
		Token t = this.tokens.pop();
		this.currentReadingLineNumber = t.getLineNumber();

		return t;
	}

	/**
	 *	Get the first token from the list without consuming
	 *
	 *	@return First token from the list
	 */
	private Token peek() {
		return this.tokens.peek();
	}

	/**
	 *	Get the token from the index of the list
	 *
	 *	@param index Index of token
	 *
	 *	@return Token from the index
	 */
	private Token peekAt(int index) {
		// Make sure it is not calling the index out of the list range
		return (this.tokens.size() > index) ? this.tokens.get(index) : null;
	}

	/**
	 *	Check if the first token id is equal to the given one
	 *
	 *	@param tid Token ID to be checked
	 *
	 *	@return True if it is equal, false otherwise.
	 */
	private boolean isToken(int tid) {

		// Make sure the token list is not empty
		if (this.tokens.size() == 0) {
			return false;
		}

		return (this.tokens.peek().getTokenId() == tid);
	}

	/**
	 *	Check if the token id at the index of the list is equal to the given one
	 *
	 *	@param index Index of token
	 *	@param tid   Token ID to be checked
	 *
	 *	@return True if it is equal, false otherwise.
	 */
	private boolean isTokenAt(int index, int tid) {

		// Make sure the index is not out of bound
		if (index < 0 || index >= this.tokens.size()) {
			return false;
		}

		return (this.tokens.get(index).getTokenId() == tid);
	}

	/**
	 *	Check if the list of token is empty
	 *
	 *	@return True if it is, false otherwise
	 */
	private boolean isEmpty() {
		return (this.tokens.size() == 0);
	}

	/**
	 *	Add error message to the list
	 *
	 *	@param message Error message
	 */
	private void err(String message) {
		this.errors.add(new ErrorHandler(message, this.currentReadingLineNumber));
	}

	/**
	 *	Add error message to the list with custom line number
	 *
	 *	@param message Error message
	 *	@param line    Line number
	 */
	private void err(String message, int line) {
		this.errors.add(new ErrorHandler(message, line));
	}

	/**
	 *	Add sementic error message to the list
	 *
	 *	@param message Error message
	 */
	private void serr(String message) {
		this.semanticErrors.add(new ErrorHandler(message, this.currentReadingLineNumber));
	}

	/**
	 *	Add error message to the list with custom line number
	 *
	 *	@param message Error message
	 *	@param line    Line number
	 */
	private void serr(String message, int line) {
		this.semanticErrors.add(new ErrorHandler(message, line));
	}

	/**
	 *	Recover error when the error occurred
	 *
	 *	@param follow Follow set
	 */
	private void errorRecovery(LinkedList<Integer> follow) {
		
		// Check till the list of token is empty
		while(this.tokens.size() > 0) {

			// If token is in follow set, then stop consuming
			if (follow.indexOf(new Integer(this.tokens.peek().getTokenId())) != -1) {
				break;
			}

			// Consume the token
			this.consume();
		}
	}

	private void pushFunctionArgsToSymbol(SymbolData symbol, TreeNode nPlist) {

		if (nPlist.getNodeValue() == TreeNode.NARRD || nPlist.getNodeValue() == TreeNode.NSDECL) {
			symbol.pushFunctionArgs(nPlist.getSymbol().getDataType());
		}

		if (nPlist.getLeftNode() != null) {
			pushFunctionArgsToSymbol(symbol, nPlist.getLeftNode());
		}

		if (nPlist.getMiddleNode() != null) {
			pushFunctionArgsToSymbol(symbol, nPlist.getMiddleNode());
		}

		if (nPlist.getRightNode() != null) {
			pushFunctionArgsToSymbol(symbol, nPlist.getRightNode());
		}

	}

	private void pushElistLinkedList(LinkedList<Integer> l, TreeNode n) {

		if (n.getNodeValue() == TreeNode.NSIMV || n.getNodeValue() == TreeNode.NILIT || n.getNodeValue() == TreeNode.NFLIT) {
			l.add(n.getSymbol().getDataType());
		}

		if (n.getLeftNode() != null) {
			pushElistLinkedList(l, n.getLeftNode());
		}

		if (n.getMiddleNode() != null) {
			pushElistLinkedList(l, n.getMiddleNode());
		}

		if (n.getRightNode() != null) {
			pushElistLinkedList(l, n.getRightNode());
		}

	}

	// ==================================================
	// Syntax Node
	// ==================================================

	/**
	 *	<program> ::= CD18 <id> <globals> <funcs> <mainbody>
	 *
	 *	@return NPROG Node or NUNDEF Node
	 */
	private TreeNode sProgram() {

		// Declare scope
		this.scopeStack.add("global");

		// Check for keyword 'CD18'
		if (this.isToken(Token.TCD18) == false) {
			this.err("Expected 'CD18' keyword at the begining of the program");
			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume 'CD18'
		this.consume();

		// Check for CD18 identifier
		if (this.isToken(Token.TIDEN) == false) {
			this.err("Expected identifier after 'CD18'");
			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume <id>
		Token t = this.consume();

		// Create symbol data for main
		SymbolData symbol = new SymbolData(t.getTokenId(), t.getLexeme(), this.scopeStack.peekLast(), t.getLineNumber());

		// Remember main var
		this.mainVar = t.getLexeme();

		// <globals>
		TreeNode nGlobals = this.sGlobals();

		// <funcs>
		TreeNode nFuncs = this.sFuncs();

		// <mainbody>
		TreeNode nMainbody = this.sMainbody();

		return new TreeNode(TreeNode.NPROG, symbol, nGlobals, nFuncs, nMainbody);

	}

	/**
	 *	<globals> ::= <consts> <types> <arrays>
	 *
	 *	@return NGLOB Node
	 */
	private TreeNode sGlobals() {

		//Check <consts>
		TreeNode nConsts = this.sConsts();

		// Check <types>
		TreeNode nTypes = this.sTypes();

		// Check <arrays>
		TreeNode nArrays = this.sArrays();

		return new TreeNode(TreeNode.NGLOB, nConsts, nTypes, nArrays);

	}

	/**
	 *	<consts> ::= constants <initlist> | ε
	 *
	 *	@return null or <initlist>
	 */
	private TreeNode sConsts() {

		// Check for constants
		if (this.isToken(Token.TCONS)) {

			// Consume 'constants'
			this.consume();

			return this.sInitlist();

		}

		return null;

	}

	/**
	 *	<initlist> ::= <init> <initlisttail>
	 *
	 *	@return NILIST Node or <init>
	 */
	private TreeNode sInitlist() {

		// Check <init>
		TreeNode nInit = this.sInit();

		// Check <initlisttail>
		TreeNode nInitlisttail = this.sInitlisttail();

		// If no tail
		if (nInitlisttail == null) {
			
			// NINIT
			return nInit;
		}

		// NILIST
		return new TreeNode(TreeNode.NILIST, nInit, nInitlisttail, null);

	}

	/**
	 *	<initlisttail> ::= ε | , <initlist>
	 *
	 *	@return null or <initlist>
	 */
	private TreeNode sInitlisttail() {

		// Check for ','
		if (this.isToken(Token.TCOMA) == false) {
			return null;
		}

		// Consume ','
		this.consume();

		return this.sInitlist();

	}

	/**
	 *	<init> ::= <id> = <expr>
	 *
	 *	follow = {',', 'types', 'arrays', 'func', 'main'}
	 *
	 *	@return NINIT or NUNDEF Node
	 */
	private TreeNode sInit() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TCOMA));
		follow.add(new Integer(Token.TTYPS));
		follow.add(new Integer(Token.TARRS));
		follow.add(new Integer(Token.TFUNC));
		follow.add(new Integer(Token.TMAIN));

		// Check <id>
		if (this.isToken(Token.TIDEN) == false) {

			this.err("Expected identifier for constants");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume <id>
		Token t = this.consume();

		// Create symbol data
		SymbolData symbol = new SymbolData(t.getTokenId(), t.getLexeme(), this.scopeStack.peekLast(), t.getLineNumber());

		// Check '='
		if (this.isToken(Token.TEQUL) == false) {

			this.err("Unexpected " + this.peek().getLexeme(), this.peek().getLineNumber());
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume '='
		this.consume();

		// Check <expr>
		TreeNode nExpr = this.sExpr();

		// Check if this constant has already been declared
		if (this.symbolTable.has(symbol.getId())) {
			this.serr("Constant variable redeclaration.", t.getLineNumber());
		} else {
			// Only value is supported now
			symbol.setValue(nExpr.getSymbol().getName());
			symbol.setDataType(nExpr.getSymbol().getType());

			this.symbolTable.add(symbol);
		}

		return new TreeNode(TreeNode.NINIT, symbol, nExpr, null, null);

	}

	/**
	 *	<types> ::= types <typelist> | ε
	 *
	 *	@return null or <typelist>
	 */
	private TreeNode sTypes() {

		// Check 'types'
		if (this.isToken(Token.TTYPS)) {

			// Consume 'types'
			this.consume();

			return this.sTypelist();
		} 

		return null;

	}

	/**
	 *	<arrays> ::= arrays <arrdecls> | ε
	 *
	 *	@return null or <arrdecls>
	 */
	private TreeNode sArrays() {

		// Check 'arrays'
		if (this.isToken(Token.TARRS)) {

			// Consume 'arrays'
			this.consume();

			return this.sArrdecls();
		}

		return null;

	}

	/**
	 *	<funcs>	::= <func> <funcs> | ε
	 *
	 *	@return null or NFUNCS Node
	 */
	private TreeNode sFuncs() {

		// Check <func>
		TreeNode nFunc = this.sFunc();

		// Not a func
		if (nFunc == null) {
			return null;
		}

		// Check <funcs>
		TreeNode nFuncs = this.sFuncs();

		return new TreeNode(TreeNode.NFUNCS, nFunc, nFuncs, null);

	}

	/**
	 *	<mainbody> ::= main <slist> begin <stats> end CD18 <id>
	 *
	 *	@return NMAIN Node or NUNDEF Node 
	 */
	private TreeNode sMainbody() {

		// Check 'main'
		if (this.isToken(Token.TMAIN) == false) {
			this.err("Unexpected '" + this.peek().getLexeme() + "'", this.peek().getLineNumber());
			return new TreeNode(TreeNode.NUNDEF);
		}

		this.scopeStack.add("main");

		// Consume 'main'
		this.consume();

		// Check <slist>
		TreeNode nSlist = this.sSlist();

		// check 'begin'
		if (this.isToken(Token.TBEGN) == false) {
			this.err("Unexpected '" + this.peek().getLexeme() + "'", this.peek().getLineNumber());
			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume 'begin'
		this.consume();

		// Check <stats>
		TreeNode nStats = this.sStats();

		// Check 'end'
		if (this.isToken(Token.TEND) == false) {
			this.err("Expected 'end' in main body");
			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume 'end'
		this.consume();

		// Check 'CD18'
		if (this.isToken(Token.TCD18) == false) {
			this.err("Expected 'CD18' keyword");
			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume 'CD18'
		this.consume();

		// Check <id>
		if (this.isToken(Token.TIDEN) == false) {
			this.err("Expected identifier after 'CD18'");
			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume <id>
		Token t = this.consume();

		// Semantic check if main var is the same
		if (t.getLexeme().equals(this.mainVar) == false) {
			this.serr("identifier at the end of program does not match the identifier at the begining", t.getLineNumber());
		}

		return new TreeNode(TreeNode.NMAIN, nSlist, nStats, null);

	}

	/**
	 *	<slist> ::= <sdecl> <slisttail>
	 *
	 *	@return NSDlST Node or <sdecl>
	 */
	private TreeNode sSlist() {

		// Check <sdecl>
		TreeNode nSdecl = this.sSdecl();

		// Check <slisttail>
		TreeNode nSlisttail = this.sSlisttail();

		// If no tail
		if (nSlisttail == null) {

			// NSDECL
			return nSdecl;

		}

		// NSDLST
		return new TreeNode(TreeNode.NSDLST, nSdecl, nSlisttail, null);

	}

	/**
	 *	<slisttail> ::= ε | , <slist>
	 *
	 *	@return null or <slist>
	 */
	private TreeNode sSlisttail() {

		// Check ','
		if (this.isToken(Token.TCOMA) == false) {
			return null;
		}

		// Consume ','
		this.consume();

		return this.sSlist();

	}

	/**
	 *	<typelist> ::= <type> <typelisttail>
	 *
	 *	@return NTYPEL Node or <type>
	 */
	private TreeNode sTypelist() {

		// Check <type>
		TreeNode nType = this.sType();

		// Check <typelisttail>
		TreeNode nTypelisttail = this.sTypelisttail();

		// If no tail
		if (nTypelisttail == null) {

			// NRTYPE | NATYPE
			return nType;

		}

		// NTYPEL
		return new TreeNode(TreeNode.NTYPEL, nType, nTypelisttail, null);

	}

	/**
	 *	<typelisttail> ::= ε | <typelist>
	 *
	 *	@return null or <typelist>
	 */
	private TreeNode sTypelisttail() {

		// Check if there is <structid> | <typeid>
		if (this.isToken(Token.TIDEN)) {
			return this.sTypelist();
		}

		return null;
	}

	/**
	 *	<type> ::= <structid> is <fields> end
	 *	<type> ::= <typeid> is array [ <expr> ] of <structid>
	 *
	 *	follow = {'<id>', 'arrays', 'func', 'main'}
	 *
	 *	@return NATYPE Node or NRTYPE Node or NUNDEF Node
	 */
	private TreeNode sType() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TIDEN));
		follow.add(new Integer(Token.TARRS));
		follow.add(new Integer(Token.TFUNC));
		follow.add(new Integer(Token.TMAIN));

		// Check <structid> | <typeid>
		if (this.isToken(Token.TIDEN) == false) {

			this.err("Expected type identifier or struct identifier");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume <structid> | <typeid>
		Token t = this.consume();

		// Create symbol data
		SymbolData symbol = new SymbolData(t.getTokenId(), t.getLexeme(), "global", t.getLineNumber());

		// Type scope
		this.scopeStack.add("type_" + t.getLexeme());

		// Check if symobl has already been declared in this scope
		if (this.symbolTable.has(symbol.getId())) {
			this.serr("Variable redeclaration", t.getLineNumber());
		} else {
			this.symbolTable.add(symbol);
		}

		// Check 'is'
		if (this.isToken(Token.TIS) == false) {

			this.err("Expected 'is' after identifier");
			this.errorRecovery(follow);

			this.scopeStack.removeLast();

			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume 'is'
		this.consume();

		// Check 'array'
		if (this.isToken(Token.TARAY)) {

			// Consume 'array'
			this.consume();

			// Check '['
			if (this.isToken(Token.TLBRK) == false) {
				
				this.err("Expected opening bracket '['");
				this.errorRecovery(follow);

				this.scopeStack.removeLast();

				return new TreeNode(TreeNode.NUNDEF);
			}

			// Consume '['
			this.consume();

			// Check <expr>
			TreeNode nExpr = this.sExpr();

			if (nExpr.getNodeValue() != TreeNode.NILIT) {
				if (nExpr.getNodeValue() == TreeNode.NSIMV) {
					/*SymbolData tmp = nExpr.getSymbol();
					tmp.setScope("global");

					if (!this.symbolTable.has(tmp.getId())) {
						this.serr("Undefined '"+ nExpr.getSymbol().getName() +"'", nExpr.getSymbol().getLine());
					} else {
						this.symbolTable.get(symbol.getId()).setArraySize(Integer.parseInt(tmp.getValue()));
					}*/
				} else {
					this.serr("Invalid array size declaration", nExpr.getSymbol().getLine());
				}
			} else {
				this.symbolTable.get(symbol.getId()).setArraySize(Integer.parseInt(nExpr.getSymbol().getName()));
			}

			// Check ']'
			if (this.isToken(Token.TRBRK) == false) {
				
				this.err("Expected closing bracket ']'");
				this.errorRecovery(follow);

				this.scopeStack.removeLast();

				return new TreeNode(TreeNode.NUNDEF);
			}

			// Consume ']'
			this.consume();

			// Check 'of'
			if (this.isToken(Token.TOF) == false) {

				this.err("Expected 'of' after closing bracket ']'");
				this.errorRecovery(follow);

				this.scopeStack.removeLast();

				return new TreeNode(TreeNode.NUNDEF);

			}

			// Consume 'of'
			this.consume();

			// Check <structid>
			if (this.isToken(Token.TIDEN) == false) {

				this.err("Expected struct identifier after 'of'");
				this.errorRecovery(follow);

				this.scopeStack.removeLast();

				return new TreeNode(TreeNode.NUNDEF);

			}

			// Consume <structid>
			Token structIdToken = this.consume();

			SymbolData structIdSymbol = new SymbolData(structIdToken.getTokenId(), structIdToken.getLexeme(), "global", structIdToken.getLineNumber());

			if (!this.symbolTable.has(structIdSymbol.getId())) {
				this.serr("Undefined struct identifier '"+ structIdToken.getLexeme() +"'", structIdToken.getLineNumber());
			} else {
				this.symbolTable.get(symbol.getId()).linkToSymbol(structIdSymbol.getId());
			}

			this.scopeStack.removeLast();

			// NATYPE
			return new TreeNode(TreeNode.NATYPE, symbol, nExpr, null, null);

		}

		// Check <fields>
		TreeNode nFields = this.sFields();

		// Check 'end'
		if (this.isToken(Token.TEND) == false) {

			this.err("Expected 'end' for struct");
			this.errorRecovery(follow);

			this.scopeStack.removeLast();

			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume 'end'
		this.consume();

		this.scopeStack.removeLast();

		// NRTYPE
		return new TreeNode(TreeNode.NRTYPE, symbol, nFields, null, null);

	}

	/**
	 *	<fields> ::= <sdecl> <fieldstail>
	 *
	 *	@return NFLIST Node or <sdecl>
	 */
	private TreeNode sFields() {

		// Check <sdecl>
		TreeNode nSdecl = this.sSdecl();

		// Check <fieldstail>
		TreeNode nFieldstail = this.sFieldstail();

		// If no tail
		if (nFieldstail == null) {
			return nSdecl;
		}

		return new TreeNode(TreeNode.NFLIST, nSdecl, nFieldstail, null);

	}

	/**
	 *	<fieldstail> =  ε | , <fields>
	 *
	 *	@return null or <fields>
	 */
	private TreeNode sFieldstail() {

		// Check ','
		if (this.isToken(Token.TCOMA) == false) {
			return null;
		}

		// Consume ','
		this.consume();

		return this.sFields();
	}

	/**
	 *	<sdecl> ::= <id> : <stype>
	 *
	 *	follow = {'end', 'arrays', 'func', 'main', 'const', 'begin', ','}
	 *
	 *	@return NSDECL Node or NUNDEF Node
	 */
	private TreeNode sSdecl() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TEND));
		follow.add(new Integer(Token.TARRS));
		follow.add(new Integer(Token.TFUNC));
		follow.add(new Integer(Token.TMAIN));
		follow.add(new Integer(Token.TCNST));
		follow.add(new Integer(Token.TBEGN));
		follow.add(new Integer(Token.TCOMA));

		// Check <sdecl>
		if (this.isToken(Token.TIDEN) == false) {

			this.err("Expected identifier");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume <id>
		Token t = this.consume();

		// Create symbol
		SymbolData symbol = new SymbolData(t.getTokenId(), t.getLexeme(), this.scopeStack.peekLast(), t.getLineNumber());

		// Check ':'
		if (this.isToken(Token.TCOLN) == false) {

			this.err("Expected ':' after identifier");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume ':'
		this.consume();

		// Check <stype>
		TreeNode nStype = null;

		// Check if symobl has already been declared in this scope
		if (this.symbolTable.has(symbol.getId())) {
			this.serr("Variable redeclaration", t.getLineNumber());

			nStype = this.sStype(null);
		} else {
			symbol.setAddress(this.symbolTable.bmcounter[1]);
			this.symbolTable.add(symbol);

			this.symbolTable.bmcounter[1] += 8;

			nStype = this.sStype(symbol);
		}
		
		// NSDECL
		return new TreeNode(TreeNode.NSDECL, symbol, nStype, null, null);

	}

	/**
	 *	<arrdecls> ::= <arrdecl> <arrdeclstail>
	 *
	 *	@return NALIST Node or <arrdecl>
	 */
	private TreeNode sArrdecls() {

		// Check <arrdecl>
		TreeNode nArrdecl = this.sArrdecl();

		// Check <arrdeclstail>
		TreeNode nArrdeclstail = this.sArrdeclstail();

		// If no tail
		if (nArrdeclstail == null) {

			// NARRD
			return nArrdecl;

		}

		// NALIST
		return new TreeNode(TreeNode.NALIST, nArrdecl, nArrdeclstail, null);

	}

	/**
	 *	<arrdeclstail> ::= ε | , <arrdecls>
	 *
	 *	@return null or <arrdecls>
	 */
	private TreeNode sArrdeclstail() {

		// Check ','
		if (this.isToken(Token.TCOMA) == false) {
			return null;
		}

		// Consume ','
		this.consume();

		return this.sArrdecls();

	}

	/**
	 *	<arrdecl> ::= <id> : <typeid>
	 *
	 *	follow = {'end', 'arrays', 'func', 'main', 'const', 'begin', ','}
	 *
	 *	@return NARRD Node or NUNDEF Node
	 */
	private TreeNode sArrdecl() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TEND));
		follow.add(new Integer(Token.TARRS));
		follow.add(new Integer(Token.TFUNC));
		follow.add(new Integer(Token.TMAIN));
		follow.add(new Integer(Token.TCNST));
		follow.add(new Integer(Token.TBEGN));
		follow.add(new Integer(Token.TCOMA));

		// Check <id>
		if (this.isToken(Token.TIDEN) == false) {

			this.err("Unexpected " + this.peek().getLexeme(), this.peek().getLineNumber());
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume <id>
		Token t = this.consume();

		// Create symbol
		SymbolData symbol = new SymbolData(t.getTokenId(), t.getLexeme(), this.scopeStack.peekLast(), t.getLineNumber());

		// Check ':'
		if (this.isToken(Token.TCOLN) == false) {

			this.err("Expected ':' after identifier");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume ':'
		this.consume();

		// Check <typeid>
		if (this.isToken(Token.TIDEN) == false) {

			this.err("Expected type identifier");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);
		}

		// Check if symobl has already been declared in this scope
		if (this.symbolTable.has(symbol.getId())) {
			this.serr("Variable redeclaration", t.getLineNumber());
		} else {
			this.symbolTable.add(symbol);
		}

		// Consume <typeid>
		Token typeIdToken = this.consume();

		SymbolData typeIdSymbol = new SymbolData(typeIdToken.getTokenId(), typeIdToken.getLexeme(), "global", typeIdToken.getLineNumber());

		// Check if symobl has already been declared in this scope
		if (!this.symbolTable.has(typeIdSymbol.getId())) {
			this.serr("Undefined type identifier.", typeIdToken.getLineNumber());
		} else {
			this.symbolTable.get(symbol.getId()).setDataType(typeIdToken.getTokenId());
			this.symbolTable.get(symbol.getId()).linkToSymbol(typeIdSymbol.getId());
		}

		return new TreeNode(TreeNode.NARRD, symbol);

	}

	/**
	 *	<func> ::= func <id> ( <plist> ) : <rtype> <funcbody>
	 *
	 *	follow = {'func', 'main'}
	 *
	 *	@return NFUND Node or NUNDEF Node
	 */
	private TreeNode sFunc() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TMAIN));
		follow.add(new Integer(Token.TFUNC));

		// Check 'func'
		if (this.isToken(Token.TFUNC) == false) {
			return null;
		}

		// Consume 'func'
		this.consume();

		// Check <id>
		if (this.isToken(Token.TIDEN) == false) {

			this.err("Expected function identifier");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume <id>
		Token t = this.consume();

		this.scopeStack.add("func_" + t.getLexeme());

		// Create symbol data
		SymbolData symbol = new SymbolData(t.getTokenId(), t.getLexeme(), "global", t.getLineNumber());
		symbol.setFunction(true);

		// Check '('
		if (this.isToken(Token.TLPAR) == false) {

			this.err("Expected opening param '('");
			this.errorRecovery(follow);

			this.scopeStack.removeLast();

			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume '('
		this.consume();

		// Check <plist>
		TreeNode nPlist = this.sPlist();

		// Some hack to push args to Symbol
		this.pushFunctionArgsToSymbol(symbol, nPlist);

		// Check ')'
		if (this.isToken(Token.TRPAR) == false) {

			this.err("Expected closing param ')'");
			this.errorRecovery(follow);

			this.scopeStack.removeLast();

			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume ')'
		this.consume();

		// Check ':'
		if (this.isToken(Token.TCOLN) == false) {

			this.err("Expected ':'");
			this.errorRecovery(follow);

			this.scopeStack.removeLast();

			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume ':'
		this.consume();

		// Check <rtype>
		TreeNode nRtype = null;

		// Check if symobl has already been declared in this scope
		if (this.symbolTable.has(symbol.getId())) {
			this.serr("Function redeclaration", t.getLineNumber());

			nRtype = this.sRtype(null);
		} else {
			this.symbolTable.add(symbol);

			nRtype = this.sRtype(symbol);
		}

		// <rtype> = void
		if (nRtype == null) {

			// Check <funcbody>
			TreeNode nFuncbody = this.sFuncbody();

			// Valid <funcbody>
			if (nFuncbody.getNodeValue() != TreeNode.NUNDEF) {

				this.scopeStack.removeLast();
				return new TreeNode(TreeNode.NFUND, symbol, nPlist, nFuncbody.getLeftNode(), nFuncbody.getMiddleNode());
			}

			this.scopeStack.removeLast();

			return new TreeNode(TreeNode.NFUND, symbol, nPlist, new TreeNode(TreeNode.NUNDEF), null);
		}

		this.scopeStack.removeLast();

		return new TreeNode(TreeNode.NFUND, symbol, nPlist, nRtype, null);

	}

	/**
	 *	<rtype> ::= <stype> | void
	 *
	 *	@return null or <stype>
	 */
	private TreeNode sRtype(SymbolData symbol) {

		// check 'void'
		if (this.isToken(Token.TVOID)) {
			this.consume();
			return null;
		}

		return this.sStype(symbol);
	}

	/**
	 *	<plist> ::= <params> | ε
	 *
	 *	@return null or <params>
	 */
	private TreeNode sPlist() {

		// Check if empty
		// If closing param, then no plist
		if (this.isToken(Token.TRPAR)) {
			return null;
		}

		return this.sParams();

	}

	/**
	 *	<params> ::= <param> <paramstail>
	 *
	 *	@return NPLIST Node or <param>
	 */
	private TreeNode sParams() {

		// Check <param>
		TreeNode nParam = this.sParam();

		// Check <paramstail>
		TreeNode nParamstail = this.sParamstail();

		// if no tail
		if (nParamstail == null) {
			return nParam;
		}

		return new TreeNode(TreeNode.NPLIST, nParam, nParamstail, null);
	}

	/**
	 *	<paramstail> ::= ε | , <params>
	 *
	 *	@return null or <params>
	 */
	private TreeNode sParamstail() {

		// Check ','
		if (this.isToken(Token.TCOMA) == false) {
			return null;
		}

		// Consume ','
		this.consume();

		return this.sParams();
	}

	/**
	 *	<param> ::= <sdecl> | <arrdecl> | const <arrdecl>
	 *
	 *	@return NARRC Node or NARRP Node or NSIMP Node
	 */
	private TreeNode sParam() {

		// Check 'const'
		if (this.isToken(Token.TCNST)) {
			return new TreeNode(TreeNode.NARRC, this.sArrdecl(), null, null);
		}

		// Check if <sdecl> | <arrdecl>
		if (this.isTokenAt(2, Token.TIDEN)) {
			return new TreeNode(TreeNode.NARRP, this.sArrdecl(), null, null);
		}

		return new TreeNode(TreeNode.NSIMP, this.sSdecl(), null, null);

	}

	/**
	 *	<funcbody> ::= <locals> begin <stats> end
	 *
	 *	follow = {'func', 'main'}
	 *
	 *	@return NFUND Node or NUNDEF Node
	 */
	private TreeNode sFuncbody() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TMAIN));
		follow.add(new Integer(Token.TFUNC));

		// Check <locals>
		TreeNode nLocals = this.sLocals();

		// Check 'begin'
		if (this.isToken(Token.TBEGN) == false) {

			this.err("Expected 'begin' in function body");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume 'begin'
		this.consume();

		// Check <stats>
		TreeNode nStats = this.sStats();

		// Check 'end'
		if (this.isToken(Token.TEND) == false) {

			this.err("Expected 'end' in function body");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume 'end'
		this.consume();

		return new TreeNode(TreeNode.NFUND, nLocals, nStats, null);

	}

	/**
	 *	<locals> ::= <dlist> | ε
	 *
	 *	@return null or <dlist>
	 */
	private TreeNode sLocals() {

		// Check if there is 'begin'
		if (this.isToken(Token.TBEGN)) {
			return null;
		}

		// Check <dlist>
		TreeNode nDlist = this.sDlist();

		return nDlist;

	}

	/**
	 *	<dlist> ::= <decl> <dlisttail>
	 *
	 *	@return NDLIST Node or <decl>
	 */
	private TreeNode sDlist() {

		// Check <decl>
		TreeNode nDecl = this.sDecl();

		// Check <dlisttail>
		TreeNode nDlisttail = this.sDlisttail();

		// If no tail
		if (nDlisttail == null) {
			return nDecl;
		}

		return new TreeNode(TreeNode.NDLIST, nDecl, nDlisttail, null);

	}

	/**
	 *	<dlisttail> ::= ε | , <dlist>
	 *
	 *	@return null or <dlist>
	 */
	private TreeNode sDlisttail() {

		// Check ','
		if (this.isToken(Token.TCOMA) == false) {
			return null;
		}

		// Consume ','
		this.consume();

		// Check <dlist>
		return this.sDlist();

	}

	/**
	 *	<decl> ::= <sdecl> | <arrdecl>
	 *
	 *	@return <sdecl> or <arrdecl>
	 */
	private TreeNode sDecl() {

		// Check if this is array
		if (this.isTokenAt(2, Token.TIDEN)) {
			// <arrdecl>
			return this.sArrdecl();
		}

		// <sdecl>
		return this.sSdecl();

	}

	/**
	 *	<stype> ::= integer | real | boolean
	 *
	 *	follow = {',', 'func', 'main'}
	 *
	 *	@return null or NUNDEF
	 */
	private TreeNode sStype(SymbolData symbol) {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TCOMA));
		follow.add(new Integer(Token.TMAIN));
		follow.add(new Integer(Token.TFUNC));

		if (this.isToken(Token.TINTG) || this.isToken(Token.TREAL) || this.isToken(Token.TBOOL)) {
			Token t = this.consume();

			if (symbol != null) {
				symbol.setDataType(t.getTokenId());
				this.symbolTable.add(symbol);
			}

			return null;
		}

		this.err("Expected type 'integer', 'real' or 'bool'");
		this.errorRecovery(follow);

		return new TreeNode(TreeNode.NUNDEF);

	}

	/**
	 *	<stats> ::= <stat> ; <statstail> | <strstat> <statstail>
	 *	
	 *	follow = {'end', 'else'}
	 *	
	 *	@return NSTATS Node or NUNDEF Node
	 */
	private TreeNode sStats() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TEND));
		follow.add(new Integer(Token.TELSE));

		if (this.sStatCheck() == false) {

			// Check <strstat>
			TreeNode nStrstat = this.sStrstat();

			// Check <statstail>
			TreeNode nStatstail = this.sStatstail();

			// If no tail
			if (nStatstail == null) {
				return nStrstat;
			}

			return new TreeNode(TreeNode.NSTATS, nStrstat, nStatstail, null);

		}

		// Check <stat>
		TreeNode nStat = this.sStat();

		// Check ';'
		if (this.isToken(Token.TSEMI) == false) {

			this.err("Expected ';'");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume ';'
		this.consume();

		// Check <statstail>
		TreeNode nStatstail = this.sStatstail();

		// If no tail
		if (nStatstail == null) {
			return nStat;
		}

		return new TreeNode(TreeNode.NSTATS, nStat, nStatstail, null);

	}

	/**
	 *	<statstail>	::= ε | <stats>
	 *
	 *	@return null or <stats>
	 */
	private TreeNode sStatstail() {

		// Check for <stat>
		if (this.sStatCheck() == false && this.sStrstatCheck() == false) {
			return null;
		}

		return this.sStats();
	}

	/**
	 *	<strstat> ::= <forstat> | <ifstat>
	 *
	 *	@return <forstat> or <ifstat> or null
	 */
	private TreeNode sStrstat() {

		// Check <forstat>
		TreeNode nForstat = this.sForstat();

		if (nForstat != null) {
			return nForstat;
		}

		// Check <ifstat>
		TreeNode nIfstat = this.sIfstat();

		if (nIfstat != null) {
			return nIfstat;
		}

		return null;

	}

	/**
	 *	Check <strstat>
	 *
	 *	@return True if token is TFOR or TIFTH, false otherwise
	 */
	private boolean sStrstatCheck() {
		return (this.isToken(Token.TFOR) || this.isToken(Token.TIFTH));
	}

	/**
	 *	<stat> ::= <reptstat> | <asgnstat> | <iostat> | <callstat> | <returnstat>
	 *
	 *	@return <repstat> or <asgnstat> or <iostat> or <callstat> or <returnstat> or null
	 */
	private TreeNode sStat() {

		// Check <repstat>
		TreeNode nRepstat = this.sRepstat();

		if (nRepstat != null) {
			return nRepstat;
		}

		// Check <callstat>
		TreeNode nCallstat = this.sCallstat();

		if (nCallstat != null) {
			return nCallstat;
		}

		// Check <asgnstat>
		TreeNode nAsgnstat = this.sAsgnstat();

		if (nAsgnstat != null) {
			return nAsgnstat;
		}

		// Check <iostat>
		TreeNode nIostat = this.sIostat();

		if (nIostat != null) {
			return nIostat;
		}

		// Check <returnstat>
		TreeNode nReturnstat = this.sReturnstat();

		if (nReturnstat != null) {
			return nReturnstat;
		}

		return null;

	}

	/**
	 *	Check <stat>
	 *
	 *	@return True if token is TREPT or TIDEN or TINPT or TPRIN or TPRLN or TRETN, false otherwise
	 */
	private boolean sStatCheck() {
		return (this.isToken(Token.TREPT) || this.isToken(Token.TIDEN) || this.isToken(Token.TINPT) ||
				this.isToken(Token.TPRIN) || this.isToken(Token.TPRLN) || this.isToken(Token.TRETN));
	}

	/**
	 *	<forstat> ::= for ( <asgnlist> ; <bool> ) <stats> end
	 *
	 *	follow = {'end'}
	 *
	 *	@return null or NUNDEF Node or NFOR
	 */
	private TreeNode sForstat() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TEND));

		// Check 'for'
		if (this.isToken(Token.TFOR) == false) {
			return null;
		}

		// Consume 'for'
		this.consume();

		// For scope
		String forScope = "for";
		int i = 1;
		while(this.scopeStack.contains(forScope)) {
			forScope = forScope + Integer.toString(i);
			i++;
		}

		this.scopeStack.add(forScope);

		// Check '('
		if (this.isToken(Token.TLPAR) == false) {

			this.err("Expected opening param '(");
			this.errorRecovery(follow);

			this.scopeStack.removeLast();

			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume '('
		this.consume();

		// Check <asgnlist>
		TreeNode nAsgnlist = this.sAsgnlist();

		// Check ';'
		if (this.isToken(Token.TSEMI) == false) {

			this.err("Expected ';'");
			this.errorRecovery(follow);

			this.scopeStack.removeLast();

			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume ';'
		this.consume();

		// Check <bool>
		TreeNode nBool = this.sBool();

		// Check ')'
		if (this.isToken(Token.TRPAR) == false) {

			this.err("Expected closing param ')'");
			this.errorRecovery(follow);

			this.scopeStack.removeLast();

			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume ')'
		this.consume();

		// Check <stats>
		TreeNode nStats = this.sStats();

		// Check 'end'
		if (this.isToken(Token.TEND) == false) {

			this.err("Expected 'end'");
			this.errorRecovery(follow);

			this.scopeStack.removeLast();

			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume 'end'
		this.consume();

		this.scopeStack.removeLast();

		return new TreeNode(TreeNode.NFOR, nAsgnlist, nBool, nStats);

	}

	/**
	 *	<repstat> ::= repeat ( <asgnlist> ) <stats> until <bool>
	 *
	 *	follow = {';', 'end'}
	 *
	 *	@return null or NUNDEF Node or NREPT Node
	 */
	private TreeNode sRepstat() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TSEMI));
		follow.add(new Integer(Token.TEND));

		// Check 'repeat'
		if (this.isToken(Token.TREPT) == false) {
			return null;
		}

		// Consume 'repeat'
		this.consume();

		// Check '('
		if (this.isToken(Token.TLPAR) == false) {

			this.err("Expected opening param '(");
			this.errorRecovery(follow);
			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume '('
		this.consume();

		// Check <asgnlist>
		TreeNode nAsgnlist = this.sAsgnlist();

		// Check ')'
		if (this.isToken(Token.TRPAR) == false) {

			this.err("Expected opening param ')'");
			this.errorRecovery(follow);
			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume ')'
		this.consume();

		// Check <stats>
		TreeNode nStats = this.sStats();

		// Check 'until'
		if (this.isToken(Token.TUNTL) == false) {

			this.err("Expected 'until'");
			this.errorRecovery(follow);
			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume 'until'
		this.consume();

		// Check <bool>
		TreeNode nBool = this.sBool();

		return new TreeNode(TreeNode.NREPT, nAsgnlist, nStats, nBool);
	}

	/**
	 *	<asgnlist> ::=	<alist> | ε
	 *
	 *	@return null or <alist>
	 */
	private TreeNode sAsgnlist() {

		// Check for empty
		if (this.isToken(Token.TIDEN) == false) {
			return null;
		}

		return this.sAlist();
	}

	/**
	 *	<alist>	::= <asgnstat> <alisttail>
	 *
	 *	@return NASGNS Node or <asgnstat>
	 */
	private TreeNode sAlist() {

		// Check <asgnstat>
		TreeNode nAsgnstat = this.sAsgnstat();

		// Check <alisttail>
		TreeNode nAlisttail = this.sAlisttail();

		// If no tail
		if (nAlisttail == null) {
			return nAsgnstat;
		}

		return new TreeNode(TreeNode.NASGNS, nAsgnstat, nAlisttail, null);

	}

	/**
	 *	<alisttail>	::= ε | , <alist>
	 *
	 *	@return null or <alist>
	 */
	private TreeNode sAlisttail() {

		// Check ','
		if (this.isToken(Token.TCOMA) == false) {
			return null;
		}

		// Consume ','
		this.consume();

		return this.sAlist();
	}

	/**
	 *	<ifstat> ::= if ( <bool> ) <stats> end
	 * 	<ifstat> ::= if ( <bool> ) <stats> else <stats> end
	 *
	 *	follow = {'end'}
	 *
	 *	@return null or NUNDEF Node or NIFTH Node or NIFTE Node
	 */
	private TreeNode sIfstat() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TEND));

		// Check 'if'
		if (this.isToken(Token.TIFTH) == false) {
			return null;
		}

		// Consume 'if'
		this.consume();

		// Check '('
		if (this.isToken(Token.TLPAR) == false) {

			this.err("Expected opening param '(");
			this.errorRecovery(follow);
			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume '('
		this.consume();

		// Check <bool>
		TreeNode nBool = this.sBool();

		// Check ')'
		if (this.isToken(Token.TRPAR) == false) {

			this.err("Expected closing param ')'");
			this.errorRecovery(follow);
			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume ')'
		this.consume();

		// Check <stats>
		TreeNode nStats = this.sStats();

		// Check 'end'
		if (this.isToken(Token.TEND)) {

			// Consume 'end'
			this.consume();

			return new TreeNode(TreeNode.NIFTH, nBool, nStats, null);
		}

		// Check 'else'
		if (this.isToken(Token.TELSE) == false) {

			this.err("Unexpected " + this.peek().getLexeme(), this.peek().getLineNumber());
			this.errorRecovery(follow);
			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume 'else'
		this.consume();

		// Check <stats>
		TreeNode nStats2 = this.sStats();

		// Check 'end'
		if (this.isToken(Token.TEND) == false) {

			this.err("Expected 'end'");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume 'end'
		this.consume();

		return new TreeNode(TreeNode.NIFTE, nBool, nStats, nStats2);

	}

	/**
	 *	<asgnstat> ::= <var> <asgnop> <bool>
	 *
	 *	follow = {';', 'end'}
	 *
	 *	@return <asgnop> or null
	 */
	private TreeNode sAsgnstat() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TSEMI));
		follow.add(new Integer(Token.TEND));

		// Check to return null
		if (this.isToken(Token.TIDEN) == false) {
			return null;
		}

		// Check <var>
		TreeNode nVar = this.sVar();

		// Check <asgnop>
		TreeNode nAsgnop = this.sAsgnop();

		// Check <bool>
		TreeNode nBool = this.sBool();

		if (nAsgnop == null) {
			this.err("Expected assign operator");
			this.errorRecovery(follow);
			return new TreeNode(TreeNode.NUNDEF);
		}

		return new TreeNode(nAsgnop.getNodeValue(), nVar, nBool, null);
	}

	/**
	 *	<asgnop> ::= = | += | -= | *= | /=
	 *
	 *	@return NASGN Node or NPLEQ Node or NMNEQ Node or NSTEQ Node or NDVEQ Node or null
	 */
	private TreeNode sAsgnop() {

		// Check '='
		if (this.isToken(Token.TEQUL)) {
			this.consume();
			return new TreeNode(TreeNode.NASGN);
		}

		// Check '+='
		if (this.isToken(Token.TPLEQ)) {
			this.consume();
			return new TreeNode(TreeNode.NPLEQ);
		}

		// Check '-='
		if (this.isToken(Token.TMNEQ)) {
			this.consume();
			return new TreeNode(TreeNode.NMNEQ);
		}

		// Check '*='
		if (this.isToken(Token.TSTEQ)) {
			this.consume();
			return new TreeNode(TreeNode.NSTEQ);
		}

		// Check '/='
		if (this.isToken(Token.TDVEQ)) {
			this.consume();
			return new TreeNode(TreeNode.NDVEQ);
		}

		return null;
	}

	/**
	 *	<iostat> ::= input <vlist> | print <prlist> | printline <prlist>
	 *
	 *	@return null or NINPUT Node or NPRINT Node or NPRLN Node
	 */
	private TreeNode sIostat() {

		if (this.isToken(Token.TINPT)) {

			// Consume 'input'
			this.consume();

			// Check <vlist>
			TreeNode nVlist = this.sVlist();

			return new TreeNode(TreeNode.NINPUT, nVlist, null, null);

		} else if (this.isToken(Token.TPRIN)) {

			// Consume 'print'
			this.consume();

			// Check <prlist>
			TreeNode nPrlist = this.sPrlist();

			return new TreeNode(TreeNode.NPRINT, nPrlist, null, null);

		} else if (this.isToken(Token.TPRLN)) {

			// Consume 'printline'
			this.consume();

			// Check <prlist>
			TreeNode nPrlist = this.sPrlist();

			return new TreeNode(TreeNode.NPRLN, nPrlist, null, null);

		} 

		return null;

	}

	/**
	 *	<callstat> ::= <id> ( <callstattail>
	 *
	 *	follow = {';', 'end'}
	 *
	 *	@return null or NCALL Node or NUNDEF Node
	 */
	private TreeNode sCallstat() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TSEMI));
		follow.add(new Integer(Token.TEND));

		// Check <id>
		if (this.isToken(Token.TIDEN) == false) {
			return null;
		}

		// Check '('
		if (this.isTokenAt(1, Token.TLPAR) == false) {
			return null;
		}

		// Consume <id>
		Token tid = this.consume();

		// Create symbol
		SymbolData symbol = new SymbolData(tid.getTokenId(), tid.getLexeme(), "global", tid.getLineNumber());


		// Check '('
		if (this.isToken(Token.TLPAR) == false) {

			this.err("Expected opening param '(");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume '('
		this.consume();

		// Check <callstattail>
		TreeNode nCallstattail = this.sCallstattail();

		// check symbol table
		if (!this.symbolTable.has(symbol.getId())) {
			this.serr("Undefined function.");
		} else {

			// ElistLinkedList
			// Some hack to check params
			LinkedList<Integer> elistLinkedList = new LinkedList<Integer>();

			this.pushElistLinkedList(elistLinkedList, nCallstattail);

			if (elistLinkedList.size() != this.symbolTable.get(symbol.getId()).getFunctionArgs().size()) {
				this.serr("Number of parameter arguments do not match.");
			} else {

				boolean sameType = true;

				for(int i = 0; i < elistLinkedList.size(); i++) {
					if (elistLinkedList.get(i) != this.symbolTable.get(symbol.getId()).getFunctionArgs().get(i)) {
						sameType = false;
						break;
					}
				}

				if (sameType == false) {
					this.serr("Function parameter argument type is not the same.");
				}

			}
		}

		if (nCallstattail.getNodeValue() == TreeNode.NUNDEF) {

			this.err("Expected closing ')'");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);
		}

		return new TreeNode(TreeNode.NCALL, symbol, nCallstattail, null, null);

	}

	/**
	 *	<callstattail>  ::= <elist> ) | )
	 *
	 *	follow = {';', 'end'}
	 *
	 *	@return null or NUNDEF Node or <elist>
	 */
	private TreeNode sCallstattail() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TFUNC));
		follow.add(new Integer(Token.TMAIN));
		follow.add(new Integer(Token.TEND));

		// Check ')'
		if (this.isToken(Token.TRPAR)) {

			// Consume ')'
			this.consume();

			return null;
		}

		// Check <elist>
		TreeNode nElist = this.sElist();

		// CHeck ')'
		if (this.isToken(Token.TRPAR) == false) {
			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume ')'
		this.consume();

		return nElist;

	}

	/**
	 *	<returnstat> ::= return <returnstattail>
	 *
	 *	@return null or NRETN Node
	 */
	private TreeNode sReturnstat() {

		// Check 'return'
		if (this.isToken(Token.TRETN) == false) {
			return null;
		}

		// Consume 'return'
		this.consume();

		// Check <returnstattail>
		TreeNode nReturnstattail = this.sReturnstattail();

		// If no tail
		if (nReturnstattail == null) {
			return new TreeNode(TreeNode.NRETN);
		}

		return new TreeNode(TreeNode.NRETN, nReturnstattail, null, null);
	}

	/**
	 *	<returnstattail> ::= ε | <expr>
	 *
	 *	@return null or <expr>
	 */
	private TreeNode sReturnstattail() {

		// Check <expr>
		return this.sExpr();

	}

	/**
	 *	<vlist> ::= <var> <vlisttail>
	 *
	 *	@return <var> or <NVLIST>
	 */
	private TreeNode sVlist() {

		// Check <var>
		TreeNode nVar = this.sVar();

		// Check <vlisttail>
		TreeNode nVlisttail = this.sVlisttail();

		// if no tail
		if (nVlisttail == null) {
			return nVar;
		}

		return new TreeNode(TreeNode.NVLIST, nVar, nVlisttail, null);

	}

	/**
	 *	<vlisttail> ::= ε | , <vlist>
	 *
	 *	@return null or <vlist>
	 */
	private TreeNode sVlisttail() {

		// Check ','
		if (this.isToken(Token.TCOMA) == false) {
			return null;
		}

		// Consume ','
		this.consume();

		return this.sVlist();
	}

	/**
	 *	<var> ::= <id> <vartail>
	 *
	 *	@return NSIMV Node or NARRV Node
	 */
	private TreeNode sVar() {

		// Check <id>
		if (this.isToken(Token.TIDEN) == false) {
			return null;
		}

		// Consume <id>
		Token tid = this.consume();

		// Create symbol data
		SymbolData symbol = new SymbolData(tid.getTokenId(), tid.getLexeme(), this.scopeStack.peekLast(), tid.getLineNumber());

		SymbolData globalSymbolTest = new SymbolData(tid.getTokenId(), tid.getLexeme(), "global", tid.getLineNumber());
		SymbolData mainSymbolTest = new SymbolData(tid.getTokenId(), tid.getLexeme(), "main", tid.getLineNumber());

		if (!this.symbolTable.has(symbol.getId())) {
			if (!this.symbolTable.has(mainSymbolTest.getId())) {
				if (!this.symbolTable.has(globalSymbolTest.getId())) {
					this.serr("Undefined variable '"+ tid.getLexeme() +"'", tid.getLineNumber());
				} else {
					symbol = this.symbolTable.get(globalSymbolTest.getId());
				}
			} else {
				symbol = this.symbolTable.get(mainSymbolTest.getId());
			}
		} else {
			symbol = this.symbolTable.get(symbol.getId());
		}

		// Check <vartail>
		TreeNode nVartail = this.sVartail(symbol);

		if (nVartail == null) {
			return new TreeNode(TreeNode.NSIMV, symbol);
		}

		return new TreeNode(TreeNode.NARRV, symbol, nVartail, null, null);
	}

	/**
	 *	<vartail> ::= ε | [<expr>] . <id>
	 *
	 *	follow = {',', ';', 'end'}
	 *
	 *	@return null or NUNDEF Node or <expr>
	 */
	private TreeNode sVartail(SymbolData symbol) {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TCOMA));
		follow.add(new Integer(Token.TSEMI));
		follow.add(new Integer(Token.TEND));

		// Check '['
		if (this.isToken(Token.TLBRK) == false) {
			return null;
		}

		// Consume '['
		this.consume();

		// Check <expr>
		TreeNode nExpr = this.sExpr();

		int arrayIndex = 0;

		if (symbol.getLinkedSymbolId() != 0) {

			int max = this.symbolTable.get(symbol.getLinkedSymbolId()).getArraySize();

			if (nExpr.getNodeValue() != TreeNode.NILIT) {
				if (nExpr.getNodeValue() == TreeNode.NSIMV) {
					SymbolData tmp = nExpr.getSymbol();

					if (!this.symbolTable.has(tmp.getId())) {
						this.serr("Undefined '"+ nExpr.getSymbol().getName() +"'", nExpr.getSymbol().getLine());
					} else {
						//arrayIndex = Integer.parseInt(tmp.getValue());
						arrayIndex = 0;
					}
				} else {
					this.serr("Invalid array index");
				}
			} else {
				arrayIndex = Integer.parseInt(nExpr.getSymbol().getName());
			}

			if (max > 0) {
				if (arrayIndex < 0 || arrayIndex >= max) {
					this.serr("Array out of bound");
				}
			}
		}

		// Check ']'
		if (this.isToken(Token.TRBRK) == false) {

			this.err("Expected closing bracket ']'");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);

		}

		// Consume ']'
		this.consume();

		// Check '.'
		if (this.isToken(Token.TDOT) == false) {

			this.err("Expected '.'");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume '.'
		this.consume();

		// Check <id>
		if (this.isToken(Token.TIDEN) == false) {

			this.err("Expected identifier after '.'");
			this.errorRecovery(follow);

			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume <id>
		Token dotId = this.consume();

		if (this.symbolTable.get(symbol.getLinkedSymbolId()) != null) {

			if (this.symbolTable.get(this.symbolTable.get(symbol.getLinkedSymbolId()).getLinkedSymbolId()) != null) {

				String structScope = "type_" + this.symbolTable.get(this.symbolTable.get(symbol.getLinkedSymbolId()).getLinkedSymbolId()).getName();

				SymbolData dotIdSymbol = new SymbolData(dotId.getTokenId(), dotId.getLexeme(), structScope, dotId.getLineNumber());

				if (!this.symbolTable.has(dotIdSymbol.getId())) {
					this.serr("Accessing undefined variable '"+ dotId.getLexeme() +"'");
				}
			}
		}


		return nExpr;
	}

	/**
	 *	<elist>	::=	<bool> <elisttail>
	 *
	 *	@return <bool> or NEXPL Node
	 */
	private TreeNode sElist() {

		// Check <bool>
		TreeNode nBool = this.sBool();

		// Check <elisttail>
		TreeNode nElisttail = this.sElisttail();

		// If no tail
		if (nElisttail == null) {
			return nBool;
		}

		return new TreeNode(TreeNode.NEXPL, nBool, nElisttail, null);
	}

	/**
	 *	<elisttail> ::= ε | , <elist>
	 *
	 *	@return null or <elist>
	 */
	private TreeNode sElisttail() {

		// Check ','
		if (this.isToken(Token.TCOMA) == false) {
			return null;
		}

		// Consume ','
		this.consume();

		return this.sElist();
	}

	/**
	 *	<bool> ::= <rel> <booltail>
	 *
	 *	@return <rel> or NBOOL Node
	 */
	private TreeNode sBool() {

		// Check <rel>
		TreeNode nRel = this.sRel();

		// Check <boottail>
		TreeNode nBooltail = this.sBooltail();

		// If no tail
		if (nBooltail == null) {
			return nRel;
		}

		nBooltail.setLeftNode(nRel);

		return new TreeNode(TreeNode.NBOOL, nBooltail, null, null);
	}

	/**
	 *	<booltail> ::= <logop> <rel> <booltail> | ε
	 *
	 *	@return null or <logop>
	 */
	private TreeNode sBooltail() {

		// Check <logop>
		TreeNode nLogop = this.sLogop();

		if (nLogop == null) {
			return null;
		}

		// Check <rel>
		TreeNode nRel = this.sRel();

		// Check <booltail>
		TreeNode nBooltail = this.sBooltail();

		if (nBooltail == null) {
			return new TreeNode(nLogop.getNodeValue(), null, nRel, null);
		}



		return new TreeNode(nLogop.getNodeValue(), null, this.sBooltail(), null);

	}

	/**
	 *	<rel> ::= not <expr> <reltail> | <expr> <reltail>
	 *
	 *	@return NNOT Node or <expr>
	 */
	private TreeNode sRel() {

		// For this node
		TreeNode nRel = null;

		// Check 'not'
		if (this.isToken(Token.TNOT)) {
			nRel = new TreeNode(TreeNode.NNOT);

			// Consume 'not'
			this.consume();
		}

		// Check <expr>
		TreeNode nExpr = this.sExpr();

		// Check <reltail>
		TreeNode nReltail = this.sReltail();

		// If no tail
		if (nReltail == null) {

			// If it's not 'not' node
			if (nRel == null) {
				return nExpr;
			} 
			
			// Left child of not node
			nRel.setLeftNode(nExpr);
			return nRel;

		}

		// Set expr node to left child of tail node
		nReltail.setLeftNode(nExpr);

		// IF this is not 'not' node
		if (nRel == null) {
			return nReltail;
		} 

		// Left child of 'not' node
		nRel.setLeftNode(nReltail);

		return nRel;

	}

	/**
	 *	<reltail> ::= ε | <relop><expr>
	 *
	 *	@return null or <relop>
	 */
	private TreeNode sReltail() {

		// Check <relop>
		TreeNode nRelop = this.sRelop();

		// Check if empty
		if (nRelop == null) {
			return null;
		}

		// Check <expr>
		TreeNode nExpr = this.sExpr();

		return new TreeNode(nRelop.getNodeValue(), null, nExpr, null);
	}

	/**
	 *	<logop> ::= and | or | xor
	 *
	 *	@return NAND Node or NOR Node or NXOR Node or null
	 */
	private TreeNode sLogop() {

		if (this.isToken(Token.TAND)) {
			this.consume();
			return new TreeNode(TreeNode.NAND);
		}

		if (this.isToken(Token.TOR)) {
			this.consume();
			return new TreeNode(TreeNode.NOR);
		}

		if (this.isToken(Token.TXOR)) {
			this.consume();
			return new TreeNode(TreeNode.NXOR);
		}

		return null;

	}

	/**
	 *	<relop> ::=	== | != | > | <= | < | >=
	 *
	 *	@return NEQL Node or NNEQ Node or NGRT Node or NLEQ Node or NLSS Node or NGEQ Node or null
	 */
	private TreeNode sRelop() {

		if (this.isToken(Token.TEQEQ)) {
			this.consume();
			return new TreeNode(TreeNode.NEQL);
		}

		if (this.isToken(Token.TNEQL)) {
			this.consume();
			return new TreeNode(TreeNode.NNEQ);
		}

		if (this.isToken(Token.TGRTR)) {
			this.consume();
			return new TreeNode(TreeNode.NGRT);
		}

		if (this.isToken(Token.TLEQL)) {
			this.consume();
			return new TreeNode(TreeNode.NLEQ);
		}

		if (this.isToken(Token.TLESS)) {
			this.consume();
			return new TreeNode(TreeNode.NLSS);
		}

		if (this.isToken(Token.TGEQL)) {
			this.consume();
			return new TreeNode(TreeNode.NGEQ);
		}

		return null;
	}

	/**
	 *	<expr> ::= <fact> <exprtail>
	 *
	 *	@return <fact> or <exprtail>
	 */
	private TreeNode sExpr() {

		// Check <fact>
		TreeNode nFact = this.sFact();

		// Check <exprtail>
		TreeNode nExprtail = this.sExprtail();

		// If no tail
		if (nExprtail == null) {
			return nFact;
		}

		nExprtail.setLeftNode(nFact);

		return nExprtail;
	}

	/**
	 *	<exprtail> ::= + <fact> <exprtail> | - <fact> <exprtail> | ε
	 *
	 *	@return null or NADD Node or NSUB Node
	 */
	private TreeNode sExprtail() {

		TreeNode node = null;

		// Check if empty
		if (this.isToken(Token.TPLUS)) {
			node = new TreeNode(TreeNode.NADD);
			this.consume();
		} else if (this.isToken(Token.TMINS)) {
			node = new TreeNode(TreeNode.NSUB);
			this.consume();
		}

		if (node == null) {
			return null;
		}

		// Check <fact>
		TreeNode nFact = this.sFact();

		node.setRightNode(nFact);

		// Check <exprtail>
		TreeNode nExprtail = this.sExprtail();

		if (nExprtail == null) {
			return node;
		}

		nExprtail.setRightNode(node);

		return nExprtail;
	}

	/**
	 * 	<fact> ::= <term> <facttail>
	 *
	 *	@return <term> or <facttail>
	 */
	private TreeNode sFact() {

		// Check <term>
		TreeNode nTerm = this.sTerm();

		// Check <facttail>
		TreeNode nFacttail = this.sFacttail();

		if (nFacttail == null) {
			return nTerm;
		}

		nFacttail.setLeftNode(nTerm);
		return nFacttail;
	}

	/**
	 *	<facttail> ::= * <term> <facttail> | / <term> <facttail> | % <term> <facttail> | ε
	 *
	 *	@return null or NMUL Node or NDIV Node or NMOD Node
	 */
	private TreeNode sFacttail() {

		TreeNode node = null;

		// Check if empty
		if (this.isToken(Token.TSTAR)) {
			node = new TreeNode(TreeNode.NMUL);
		} else if (this.isToken(Token.TDIVD)) {
			node = new TreeNode(TreeNode.NDIV);
		} else if (this.isToken(Token.TPERC)) {
			node = new TreeNode(TreeNode.NMOD);
		}

		if (node == null) {
			return null;
		}

		// Consume 
		this.consume();

		// Check <term>
		TreeNode nTerm = this.sTerm();

		node.setRightNode(nTerm);

		// Check <facttail>
		TreeNode nFacttail = this.sFacttail();

		if (nFacttail == null) {
			return node;
		}

		nFacttail.setRightNode(node);
		return nFacttail;
	}

	/**
	 *	<term> ::= <exponent> <termtail>
	 *
	 *	@return <exponent> or <termtail>
	 */
	private TreeNode sTerm() {

		// Check <exponent>
		TreeNode nExponent = this.sExponent();

		// Check <termtail>
		TreeNode nTermtail = this.sTermtail();

		if (nTermtail == null) {
			return nExponent;
		}

		nTermtail.setLeftNode(nExponent);

		return nTermtail;
	}

	/**
	 *	<termtail> ::= ^ <exponent> <termtail> | ε
	 *
	 *	@return NPOW Node or null
	 */
	private TreeNode sTermtail() {

		// Check '^'
		if (this.isToken(Token.TCART) == true) {

			this.consume();

			TreeNode nExponent = this.sExponent();

			TreeNode nTermtail = this.sTermtail();

			if (nTermtail == null) {
				return nExponent;
			}

			nTermtail.setLeftNode(nExponent);

			return new TreeNode(TreeNode.NPOW, null, nTermtail, null);

		}

		return null;

	}

	/**
	 *	<exponent> ::= <var> | <intlit> | <reallit> | <fncall> | true | false
	 *  <exponent> ::= ( <bool> )
	 *
	 *	follow = {';', 'end', ','}
	 */
	private TreeNode sExponent() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TCOMA));
		follow.add(new Integer(Token.TSEMI));
		follow.add(new Integer(Token.TEND));

		// Check <fncall>
		TreeNode nFncall = this.sFncall();

		if (nFncall != null) {
			return nFncall;
		}

		// Check <var>
		TreeNode nVar = this.sVar();

		if (nVar != null) {
			return nVar;
		}

		// Check <intlit>
		if (this.isToken(Token.TILIT)) {
			Token ilit = this.consume();
			return new TreeNode(TreeNode.NILIT, new SymbolData(ilit.getTokenId(), ilit.getLexeme(), this.scopeStack.peekLast(), ilit.getLineNumber()));
		}

		// Check <reallit>
		if (this.isToken(Token.TFLIT)) {
			Token flit = this.consume();
			return new TreeNode(TreeNode.NFLIT, new SymbolData(flit.getTokenId(), flit.getLexeme(), this.scopeStack.peekLast(), flit.getLineNumber()));
		}

		if (this.isToken(Token.TTRUE)) {
			this.consume();
			return new TreeNode(TreeNode.NTRUE);
		}

		if (this.isToken(Token.TFALS)) {
			this.consume();
			return new TreeNode(TreeNode.NFALS);
		}

		if (this.isToken(Token.TLPAR)) {

			this.consume();

			TreeNode nBool = this.sBool();

			if (this.isToken(Token.TRPAR) == false) {

				this.err("Expected closing param')'");
				this.errorRecovery(follow);
				return new TreeNode(TreeNode.NUNDEF);
			}

			this.consume();

			return nBool;

		}

		return null;
	}

	/**
	 *	<fncall> ::= <id> ( <fncalltail>
	 *
	 *	follow = {',', ';', 'end'}
	 *
	 *	@return NFCALL Node or NUNDEF Node or null
	 */
	private TreeNode sFncall() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TCOMA));
		follow.add(new Integer(Token.TSEMI));
		follow.add(new Integer(Token.TEND));

		// Check <id>
		if (this.isToken(Token.TIDEN) == false || this.isTokenAt(1, Token.TLPAR) == false) {
			return null;
		}

		// Consume <id>
		Token tid = this.consume();

		// Symbol
		SymbolData symbol = new SymbolData(tid.getTokenId(), tid.getLexeme(), "global", tid.getLineNumber());

		// Check '('
		if (this.isToken(Token.TLPAR) == false) {

			this.err("Expected opening param '('");
			this.errorRecovery(follow);
			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume '('
		this.consume();

		// Check <fncalltail>
		TreeNode nFncalltail = this.sFncalltail();

		// check symbol table
		if (!this.symbolTable.has(symbol.getId())) {
			this.serr("Undefined function.");
		} else {

			// ElistLinkedList
			// Some hack to check params
			LinkedList<Integer> elistLinkedList = new LinkedList<Integer>();

			this.pushElistLinkedList(elistLinkedList, nFncalltail);

			if (elistLinkedList.size() != this.symbolTable.get(symbol.getId()).getFunctionArgs().size()) {
				this.serr("Number of parameter arguments do not match.");
			} else {

				boolean sameType = true;

				for(int i = 0; i < elistLinkedList.size(); i++) {
					if (elistLinkedList.get(i) != this.symbolTable.get(symbol.getId()).getFunctionArgs().get(i)) {
						sameType = false;
						break;
					}
				}

				if (sameType == false) {
					this.serr("Function parameter argument type is not the same.");
				}

			}
		}

		return new TreeNode(TreeNode.NFCALL, symbol, nFncalltail, null, null);
	}

	/**
	 *	<fncalltail> ::= <elist> ) | )
	 *
	 *	follow = {',', ';', 'end'}
	 *
	 *	@return NUNDEF Node or null or <elist>
	 */
	private TreeNode sFncalltail() {

		// Follow set for error recovery
		LinkedList<Integer> follow = new LinkedList<Integer>();
		follow.add(new Integer(Token.TCOMA));
		follow.add(new Integer(Token.TSEMI));
		follow.add(new Integer(Token.TEND));

		// Check ')'
		if (this.isToken(Token.TRPAR)) {
			this.consume();
			return null;
		}

		// Check <elist>
		TreeNode nElist = this.sElist();

		// Check ')'
		if (this.isToken(Token.TRPAR) == false) {

			this.err("Expected closing param ')'");
			this.errorRecovery(follow);
			return new TreeNode(TreeNode.NUNDEF);
		}

		// Consume ')'
		this.consume();

		return nElist;
	}

	/**
	 *	<prlist> ::= <printitem> <prlisttail>
	 *
	 *	@return NPRLST Node or <printitem>
	 */
	private TreeNode sPrlist() {

		// Check <printitem>
		TreeNode nPrintitem = this.sPrintitem();

		// Check <prlisttail>
		TreeNode nPrlisttail = this.sPrlisttail();

		// If no tail
		if (nPrlisttail == null) {
			return nPrintitem;
		}

		return new TreeNode(TreeNode.NPRLST, nPrintitem, nPrlisttail, null);
	}

	/**
	 *	<prlisttail> ::= ε | , <prlist>
	 *
	 *	@return null or <prlist>
	 */
	private TreeNode sPrlisttail() {

		// Check ','
		if (this.isToken(Token.TCOMA) == false) {
			return null;
		}

		// Consume ','
		this.consume();

		return this.sPrlist();
	}

	/**
	 *	<printitem> ::= <expr> | <string>
	 *
	 *	@return <expr> or NSTRG Node
	 */
	private TreeNode sPrintitem() {

		// Check <string>
		if (this.isToken(Token.TSTRG)) {

			Token str = this.consume();
			SymbolData symbol = new SymbolData(str.getTokenId(), str.getLexeme(), this.scopeStack.peekLast(), str.getLineNumber());

			return new TreeNode(TreeNode.NSTRG, symbol);
		}

		return this.sExpr();
	}

}



